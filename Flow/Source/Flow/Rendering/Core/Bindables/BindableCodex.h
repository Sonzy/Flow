#pragma once

//= Includes ====================================

#include "Flow\Rendering\Core\Bindable.h"
#include <memory>
#include <unordered_map>

//= Class Definiton ==============================

/* A map containing all in-use reusable bindables. Stored using Unique ID's generated by the objects when resolved. */
//TODO: Garbage collection to remove unused bindables (if this is the only shared_ptr reference)
class BindableCodex
{
public:

	//= Public Static Functions ==========================================

	/* Static Wrapper - See Resolve_Internal() */
	template<class T, typename ...Params>
	static std::shared_ptr<T> Resolve(Params&&...P)
	{
		//TODO: Ensure T is a bindable
		return Get().Resolve_Internal<T>(std::forward<Params>(P)...); //TODO: Learn more about this stuff
	}


	/* Returns reference to the codex */
	static BindableCodex& Get();

private:

	//= Private Functions ===============================================

	/* If a bindable instance exists, will return the instance, otherwise will create an instance */
	template<class T, typename ...Params>
	std::shared_ptr<T> Resolve_Internal(Params&&...P)
	{
		//Generate the UID for this asset
		const auto GeneratedKey = T::GenerateUID(std::forward<Params>(P)...);
		const auto FoundIndex = _Binds.find(GeneratedKey);

		//If we didnt find it, create a new one
		if (FoundIndex == _Binds.end())
		{
			auto Bind = std::make_shared<T>(std::forward<Params>(P)...);
			_Binds[GeneratedKey] = Bind;
			return Bind;
		}
		else
			return std::static_pointer_cast<T>(FoundIndex->second);
	}


private:

	//= Private Static Variables =======================================

	static BindableCodex* s_Codex;

private:

	//= Private Variables =============================================

	std::unordered_map<std::string, std::shared_ptr<Bindable>> _Binds;
};